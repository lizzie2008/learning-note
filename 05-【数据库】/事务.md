# 事务的隔离级别

数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。

1. Read UnCommitted(读未提交)
最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。
2. Read Committed(读提交)
大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。
3. Repeatable Read(重复读)
mysql的默认级别。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。
4. Serializable(序列化)
最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。

![image-20191205120126057](https://typora-lancelot.oss-cn-beijing.aliyuncs.com/typora/20191205143634-923536.png) 
- DEFAULT 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .
- READ_UNCOMMITTED 会出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 
- READ_COMMITTED  会出现不可重复读、幻读问题（锁定正在读取的行）
- REPEATABLE_READ 会出幻读（锁定所读取的所有行）
- SERIALIZABLE 保证所有的情况不会发生（锁表）

# 不同事务级别带来的并发问题

**脏读**   

脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。

![image-20191205143659460](https://typora-lancelot.oss-cn-beijing.aliyuncs.com/typora/20191205143708-480183.png) 



**不可重复读**

在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。  
在多版本并行控制机制中，当一个遇到提交冲突的事务需要回退但却被释放时，会发生不可重复读问题。

![image-20191205143728210](https://typora-lancelot.oss-cn-beijing.aliyuncs.com/typora/20191205143731-750390.png) 



在上面这个例子中，事务2提交成功，它所做的修改已经可见。然而，事务1已经读取了一个其它的值。在序列化和可重复读的隔离级别中，数据库管理系统会返回旧值，即在被事务2修改之前的值。在提交读和未提交读隔离级别下，可能会返回被更新的值，这就是“不可重复读”。  
有两个策略可以防止这个问题的发生：  
- 推迟事务2的执行，直至事务1提交或者回退。这种策略在使用锁时应用。  
- 而在多版本并行控制中，事务2可以被先提交。而事务1，继续执行在旧版本的数据上。当事务1终于尝试提交时，数据库会检验它的结果是否和事务1、事务2顺序执行时一样。如果是，则事务1提交成功。如果不是，事务1会被回退。

**幻读**

幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。  
发生的情况：没有范围锁。

![image-20191205143756015](https://typora-lancelot.oss-cn-beijing.aliyuncs.com/typora/20191205143758-924632.png)  

不可重复读的重点是修改 :   
同样的条件 ,   你读取过的数据 ,   再次读取出来发现值不一样了   
幻读的重点在于新增或者删除   
同样的条件 ,   第 1 次和第 2 次读出来的记录数不一样